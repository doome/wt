#!/usr/bin/perl

use strict;
use warnings;
no warnings qw/experimental/;
use feature qw/say switch/;
use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Time::Local;
use Data::Dumper;
use URI::Escape;
use DateTime;
use Getopt::Long;
use Encode::Locale;
use Encode;

# keyring support is optional, will be enabled only
# if the module is installed
our $have_keyring;
BEGIN {
	$have_keyring = eval {
		require Passwd::Keyring::Auto;
		Passwd::Keyring::Auto->import();
		1;
	};
}

# load config and state
my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);
my $ret = 0;

# take care of encoding for output...
binmode STDOUT, ":encoding(UTF-8)";

# and for input as well
@ARGV = map { decode(locale => $_, 1) } @ARGV;

# get subcommand
my $action = shift @ARGV;

# take aliases into account
if (defined $action and exists $state->{aliases}{$action}) {
	my @cmds = @{$state->{aliases}{$action}};
	$action = shift @cmds;
	unshift @ARGV, @cmds;
}

# jump table for subcommands
for ($action) {
	when (undef)           { list_local(); }
	when ([qw/issues :/])  { get_issues(); }
	when ([qw/alias al/ ]) { set_alias();  }
	when ([qw/start  s/ ]) { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ([qw/report r/])  { query();      }
	when ([qw/help h/])    { help();       }
	when ([qw/add a/])     { add();        }
	when ("rm")            { rm();         }
	when (/^[\-\d\+]/)     { unshift @ARGV, $action; add(); }
	default                { help();       }
}

exit($ret);

###############

sub help {
	my $action = shift // shift @ARGV // "";

	for ($action) {
		when (undef)           { pod2usage({-verbose => 99, -sections => "NAME|SYNOPSIS"});     }
		when ([qw/start s/])   { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/START"});  }
		when ([qw/alias al/ ]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ALIAS"});  }
		when ([qw/commit ci/]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/COMMIT"}); }
		when ([qw/issues :/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ISSUES"}); }
		when ([qw/report r/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/REPORT"}); }
		when ([qw/help h/])    { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/HELP"});   }
		when ([qw/add a/])     { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ADD"});    }
		when ("rm")            { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/RM"});     }
		default                { pod2usage({-verbose => 99, -sections => "NAME|SYNOPSIS"});     }
	}

	exit;
}

sub list_local {
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		print print_wtline($wt, $i++);
	}
	if (@{$state->{local}}) {
		say "";
		say summary($state->{local});
	}
	else {
		say "No local wt records.";
		$ret = 1;
	}

	print_unlogged();
}

sub set_alias {
	my $alias = shift @ARGV;

	if (defined $alias) {
		if (@ARGV) {
			$state->{aliases}{$alias} = [@ARGV];
		}
		else {
			delete $state->{aliases}{$alias};
		}
		save_state($state_fn, $state);
	}
	else {
		if (keys %{$state->{aliases}}) {
			while (my ($al, $def) = each %{$state->{aliases}}) {
				say $al, ":\t@$def";
			}
		}
		else {
			say "No defined aliases.";
			$ret = 1;
		}
	}
}

sub rm {
	my $idx = shift @ARGV;
	die "Error: specify the index of local wt record to be deleted" unless $idx;
	die "Error: no local wt records to delete\n" unless scalar @{$state->{local}};
	
	if ($idx eq "all") {
		$state->{local} = [];
		say "All local wt records deleted!";
	}
	else {
		die "Error: index must be 1..".scalar @{$state->{local}}."\n" unless $idx =~ /^\d+$/ and $idx >= 1 and $idx <= scalar @{$state->{local}};
		# at this point we should have a valid index to delete
		splice @{$state->{local}}, $idx-1, 1;
		
		# update start mark to end of last entry
		if (@{$state->{local}}) {
			$state->{current_project} = $state->{local}[-1]{project};
			$state->{start_mark} = { t => $state->{local}[-1]{end_time}, d => $state->{local}[-1]{date} };
		}
	}
	save_state($state_fn, $state); 
	list_local();
}

sub set_mark {
	my $change = 0;
	GetOptions(
		'change!' => \$change,
	) or help('start');

	unless ($change) {
		$state->{start_mark} = { t => parse_time(undef), d => parse_date(undef) };
	}

	my $project_str = shift @ARGV;
	if (defined $project_str) {
		$state->{current_project} = uc $project_str;
	}
	elsif ($change) {
		$project_str //= "";
		die "Error: project name required for wt start --change\n";
	}

	if ($change) {
		print_unlogged();
	}
	else {
		my $on_project =  defined $state->{current_project} ? "on issue $state->{current_project}" : "";
		say "Started work $on_project";
	}

	save_state($state_fn, $state); 
}

sub commit {
	my $pw = get_pw();

	my @lines = @{$state->{local}};

	for my $wtline (@lines) {
		my $json = wtline_to_jira_json($wtline);
		my $worklog_url = $config->{jira_base_url}.$config->{worklog_url};
		my $req = HTTP::Request->new('POST', $worklog_url);
		$req->header('Content-Type' => 'application/json');
		$req->authorization_basic($config->{user_name}, $pw);
		$req->content($json);

		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);
		
		if ( $response->is_success() ) {
			# delete locally stored wt line if commit was successful
			shift @{$state->{local}};
		}
		else {
			_handle_jira_error($response);
		}
	}

	save_state($state_fn, $state);
}

sub query {
	my $start_date_str = shift @ARGV;
	
	if (defined $start_date_str) {
		$start_date_str = undef if $start_date_str eq 'today';
		my $start_date = parse_date($start_date_str);
		help('report') unless defined $start_date;

		my $end_date_str = shift @ARGV;
		my $end_date = parse_date($end_date_str);

		my $project = shift @ARGV;

		my $pw = get_pw();

		my $url = $config->{jira_base_url}.$config->{worklog_url};

		my %query_hash = (dateFrom => _print_date($start_date), dateTo => _print_date($end_date), username => $config->{user_name});
		$query_hash{projectKey} = $project if defined $project;
		my $query_string = uri_escape_hash(%query_hash);

		my $req = HTTP::Request->new('GET', $url."?".$query_string);
		$req->authorization_basic($config->{user_name}, $pw);

		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);

		if ( $response->is_success() ) {
			$state->{remote} = decode_json $response->decoded_content;

			update_saved_issue_summaries($state->{remote}, from => 'remote');

			list_remote(on_error => "No worklog records in the specified date range.");

			save_state($state_fn, $state);
		}
		else {
			_handle_jira_error($response);
		}
		
	}
	else {
		# print last saved query, don't actually ask jira
		list_remote(on_error => "There is no saved query.");
	} 

}

sub get_issues {
	my $assigned_to_me = 0;
	my $summary = 0;
	my $max = 100;
	my $raw_jql;
	GetOptions(
		'assigned!' => \$assigned_to_me,
		'summary!'  => \$summary,
		'max=i'     => \$max,
		'jql=s'     => \$raw_jql,
	) or help('issues');

	my $filter = shift @ARGV;
	my @jql;
	if (defined $filter) {
		if ($raw_jql) {
			push @jql, $filter;
		}
		elsif ($summary) {
			push @jql, "summary ~ $filter";
		}
		elsif ($filter =~ /\w+-\d+/) {
			push @jql, "issue = $filter";
		}
		else {
			push @jql, "project = $filter";
		}
	}
	if ($assigned_to_me) {
		push @jql, "assignee = " . $config->{user_name};
	}
	my $jql = join " and ", @jql;
	$jql .= " order by createddate desc" if $jql;

	my $pw = get_pw();
	
	my $json = encode_json {
		"jql" => $jql,
		"startAt" => 0,
		"maxResults" => $max,
		"fields" => [
			"summary",
			"status",
			"assignee"
		]
	};
	my $jira_url = $config->{jira_base_url}.$config->{search_url};
	my $req = HTTP::Request->new('POST', $jira_url);
	$req->header('Content-Type' => 'application/json;charset=UTF-8');
	$req->authorization_basic($config->{user_name}, $pw);
	$req->content($json);

	my $ua = LWP::UserAgent->new;
	my $response = $ua->request($req);
	
	if ( $response->is_success() ) {
		my $raw_data = decode_json $response->decoded_content;
		say for reverse map { 
				sprintf "%-8s%-16s%-16s%s", 
					$_->{key}, 
					_trunc($_->{fields}{status}{name}, 15), 
					$_->{fields}{assignee}{name} // "", 
					$_->{fields}{summary}
				} 
			@{$raw_data->{issues}};

		update_saved_issue_summaries($raw_data->{issues}, from => 'issuelist');
		save_state($state_fn, $state);
	}
	else {
		_handle_jira_error($response);
	}
	
}

sub add {
	help("add") unless defined $ARGV[0];

	# get current date as default
	my $date = parse_date(undef);

	# defaults
	my $autocommit = 0;
	my $no_overlap_check = 0;
	my $activity = undef;

	# need to check if first arg is interval spec (single dash or dash-number)
	# before calling GetOptions
	unless ($ARGV[0] =~ /^\-$|^\-\d|^\+/) {
		GetOptions(
			'date=s'     => sub { $date = parse_date($_[1]); },
			'yesterday!' => sub { $date = _yesterday(); },
			'commit!'    => \$autocommit,
			'activity=s' => \$activity,
			'force!'     => \$no_overlap_check,
		) or help('add');
	}

	# first argument: from-to time or relative interval
	my $interval = shift @ARGV;
	my ($start_time, $end_time);

	# relative interval
	if (index($interval, '+') == 0) {
		if (defined $state->{start_mark}) {
			$start_time = $state->{start_mark}{t};
		}
		else {
			die "Error: no saved starting time available, you must specify the interval explicitly\n";
		}
		my $t = parse_time($interval);

		$end_time = increment_time($start_time, time_spent({H=>0, M=>0, S=>0}, $t));
	}
	# absolute interval
	else {
		my ($s, $e) = split '-', $interval;

		# If from is not specified, try to use saved start mark.
		# If there is no start mark either, give up.
		if (not defined $s or $s eq '') {
			if (defined $state->{start_mark}) {
				$start_time = $state->{start_mark}{t};
			}
			else {
				die "Error: no saved starting time available, you must specify it explicitly\n";
			}
		}
		else {
			$start_time = parse_time($s);
		}
		# end time falls back to current time if not specified
		$end_time = parse_time($e);
	}

	die "Error: ending time must be later than starting time\n" if time_spent($start_time, $end_time, noabs => 1) <= 0;

	# second argument: project
	my $project_str = shift @ARGV;
	my $project;
	if (defined $project_str) {
		if ($project_str eq "-") {
			# use saved current project
			$project = $state->{current_project};
			die "Error: no current project available\n" unless defined $project;
		}
		elsif ($project_str eq "lunch") {
			# special hack: shortcut for lunch
			$project = $config->{lunch_project};
			die "Error: lunch project is not defined, edit wt.conf\n" unless defined $project;
		}
		else {
			$project = uc $project_str;
			$project_str //= "";
			die "Error: Invalid project name '$project_str', must be in PROJECT-NUMBER format\n" unless defined $project;
		}
	}
	else {
		die "Error: project name is mandatory\n";
	}
	$project = uc $project;

	# third argument: comment
	# rest of @ARGV is concatenated so that quotes are not needed
	my $comment = "@ARGV";
	# special hack: no comment is required for lunch
	$comment = "lunch" if $comment eq '' and $project_str eq "lunch";
	die "Error: Comment is required\n" if $comment eq '';

	# activity may have been set by option
	# special hack: no comment is required for lunch
	$activity = "Break" if not defined $activity and $project_str eq "lunch";
	$activity //= 'Dev';

	# assemble ojject and save it
	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $project,
		comment    => $comment,
		activity   => $activity,
	};

	if (not ($no_overlap_check or $config->{no_overlap_check})
	and my $overlap_idx = check_overlap($wtline)) {
		die "Error: input overlaps with existing entry:\n" .
			 print_wtline($state->{local}[$overlap_idx-1], $overlap_idx) .
			 print_wtline($wtline, undef);
	}

	push @{$state->{local}}, $wtline;
	
	$state->{current_project} = $project;
	$state->{start_mark} = { t => $end_time, d => $date };

	save_state($state_fn, $state);
	list_local();

	if ($autocommit or $config->{autocommit}) {
		commit();
	}
}

###############

sub _load_json {
	my ($fn) = @_;
	open(my $FH, "<", $fn) or return undef;
	my $json = join "", <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	die "Missing key from config file: jira_base_url\n" unless defined $config->{jira_base_url};
	die "Missing key from config file: user_name\n" unless defined $config->{user_name};
	$config->{worklog_url} //= "/rest/tempo-timesheets/3/worklogs/";
	$config->{search_url}  //= "/rest/api/2/search";

	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	return _save_json($_[0], $_[1], "state");
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time});
	
	my $ojject = {
		issue => {
			key => uc $wtline->{project},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
		billedSeconds => 0,
		worklogAttributes => [
			 {
			   'value' => $wtline->{activity},
			   'key' => '_Activity_'
			 }
        ],
		author => { 
			name => $config->{user_name} 
		},
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	my $jira = shift;
	
	my ($ds, $ts) = split 'T', $jira->{dateStarted};
	my $date = parse_date($ds);
	my $start_time = parse_time($ts);
	my $end_time = increment_time($start_time, $jira->{timeSpentSeconds});
	
	return {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $jira->{issue}{key},
		comment    => $jira->{comment},
		activity   => $jira->{worklogAttributes}[0]{value},
	};
}

sub print_wtline {
	my $wt = shift;
	my $idx = shift // 'X';
	
	return join "\t",
		$idx,
		_print_date($wt->{date}),
		_print_time($wt->{start_time}),
		_print_time($wt->{end_time}),
		$wt->{project},
		$wt->{comment},
		$wt->{activity},
		"\n";
}

sub uri_escape_hash {
    my %hash = @_;
    my @pairs;
    for my $key (keys %hash) {
        push @pairs, join "=", map { uri_escape($_) } $key, $hash{$key};
    }
    return join "&", @pairs;
}

sub update_saved_issue_summaries {
	my $issuelist = shift;
	my %args = @_;

	my %actions = (
		remote => sub {
				$state->{issues}->{ $_->{issue}{key} } = $_->{issue}{summary} for @_;
			},
		issuelist => sub {
				$state->{issues}->{ $_->{key} } = $_->{fields}{summary} for @_;
			}
	);
	if (defined $args{from} and exists $actions{ $args{from} }) {
		$actions{ $args{from} }->(@$issuelist);
	}
}

sub summary {
	my $wt_arr = shift;
	
	my %times;
	my $cumulative_time = 0;
	for my $wt (@$wt_arr) {
		my $dt = time_spent($wt->{start_time}, $wt->{end_time});
		$times{ $wt->{project} } += $dt;
		$cumulative_time += $dt;
	}

	my $summary_lines = join "", map {
			sprintf("% .2f\t%s\t%s\n", ($times{$_}/3600), $_, (exists $state->{issues}{$_} ? $state->{issues}{$_} : ""))
		} 
		sort { 
			$times{$b} <=> $times{$a} 
		} 
		keys %times;
	
	return $summary_lines . "------\n" . sprintf "%.2f", $cumulative_time/3600;
}

sub list_remote {
	my %args = @_;
	my $i = 1;
	my @remote = @{$state->{remote}};
	for my $csira (@remote) {
		print print_wtline(jira_json_to_wtline($csira), $i++);
	}
	if (@remote) {
		say "";
		say summary([ map {jira_json_to_wtline($_)} @remote ]);
	}
	else {
		say $args{on_error};
		$ret = 1;
	}
}

sub print_unlogged {
	if (defined $state->{start_mark}) {
		my $today = parse_date(undef);
		my $saved = $state->{start_mark}{d};
		if ($today->{Y} == $saved->{Y} and
			$today->{M} == $saved->{M} and
			$today->{D} == $saved->{D} ) {

			my $interval = -1 * time_spent(parse_time(undef), $state->{start_mark}{t}, noabs => 1);
			if ($interval < 0) {
				say "End of last local wt entry is in the future";
			}
			else {
				my ($h, $m, $s);
				$h = int($interval / 3600); $interval -= $h * 3600;
				$m = int($interval /   60); $interval -= $m *   60;
				$s = int($interval);
				$interval = join ':', $h, pad($m), pad($s);
				my $on_project = defined $state->{current_project} ?
									" on issue $state->{current_project}" :
									"";
				my $project_summary = defined $state->{current_project} && exists $state->{issues}->{ $state->{current_project} } ?
									"\t".$state->{issues}->{ $state->{current_project} } :
									"";
				say "Unlogged work: ", $interval, $on_project, $project_summary;
			}
		}
	}
}

sub _handle_jira_error {
	my $response = shift;

	warn "JIRA responded with ".$response->status_line."\n";
	if ($response->code() == 401) {
		forget_pw();
	}
	else {
		my $error = decode_json $response->decoded_content;
		say STDERR join "\n", @{$error->{errorMessages}};
	}
	$ret = 1;
}

###############

sub _print_date {
	join "-", map { pad($_[0]->{$_}) } qw/Y M D/;
}

sub _print_time {
	join ":", map { pad($_[0]->{$_}) } qw/H M S/;
}

sub _wt2tfe {
	my ($t, $d) = @_;
	return timelocal(
		$t->{S}, $t->{M},   $t->{H}, 
		$d->{D}, $d->{M}-1, $d->{Y}
	);
}

sub check_overlap {
	my $new = shift;
	
	my $new_start = _wt2tfe($new->{start_time}, $new->{date});
	my $new_end   = _wt2tfe($new->{end_time},   $new->{date});
	
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		my $wt_start = _wt2tfe($wt->{start_time}, $wt->{date});
		my $wt_end   = _wt2tfe($wt->{end_time},   $wt->{date});
		
		return $i unless (($new_start <= $wt_end and $new_end <= $wt_start) or ($new_start >= $wt_end and $new_end >= $wt_start));
		$i++;
	}
	
	return 0;
}

# if date is defined, try to parse it from YYYY-MM-DD or MM-DD or DD string, otherwise get current date
# if year or month is missing, it is substituted from current date
sub parse_date {
	my $dstr = shift;

	my @lt = localtime(time);
	my $date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};
	
	if (defined $dstr and $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$date->{D} = 0+$dstr;
		}
		elsif ($dstr =~ /^(\d\d?)-(\d\d?)$/) {
			$date->{M} = 0+$1;
			$date->{D} = 0+$2;
		}
		elsif ($dstr =~ /^(\d{4})-(\d\d?)-(\d\d?)$/) {
			$date->{Y} = 0+$1;
			$date->{M} = 0+$2;
			$date->{D} = 0+$3;
		}
		else {
			$date = undef;
		}

		unless (defined $date) {
			die "Invalid date specifier, must be one of YYYY-MM-DD or MM-DD or DD\n";
		}
	}
	return $date;
}

# if time is defined, try to parse it from HH-MM-SS or HH-MM or HH string, otherwise get current time
# if minutes or seconds are missing, they are assumed to be zero (whole hour/minute)
# +HH:MM or +HH.H or +MMm relative intervals are also parsed here
sub parse_time {
	my $dstr = shift;

	my @lt = localtime(time);
	my $time = {H => $lt[2], M => $lt[1], S => $lt[0]};

	my $is_interval = 0;
	if (defined $dstr and $dstr ne '') {
		if (index($dstr, '+') == 0) {
			substr($dstr, 0, 1, '');
			$is_interval = 1;
		}

		if ($is_interval and $dstr =~ /^(\d\d?)\.(\d+)$/) {
			$time->{H} = 0+$1;
			$time->{M} = int($2 * 6 + 0.5); # * 60 / 10
			$time->{S} = 0;
		}
		elsif ($is_interval and $dstr =~ /^(\d+)m$/) {
			my $m = 0+$1;
			$time->{H} = int($m / 60);
			$time->{M} = $m % 60;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^(?:[01]?\d|2[0-3])$/) {
			$time->{H} = 0+$dstr;
			$time->{M} = $time->{S} = 0;
		}
		elsif ($dstr =~ /^([01]?\d|2[0-3]):([0-5]?\d)$/) {
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^([01]?\d|2[0-3]):([0-5]?\d):([0-5]?\d)/) { # drop fractional seconds
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0+$3;
		}
		else {
			$time = undef;
		}
		unless (defined $time) {
			if ($is_interval) {
				die "Invalid interval spec '$dstr', must be one of +HH:MM:SS, +HH:MM, +HH, +MMm\n";
			}
			else {
				die "Invalid time spec '$dstr', must be one of HH:MM:SS, HH:MM, HH\n";
			}
		}
	}
	return $time;
}

sub _trunc {
	my ($text, $len) = @_;
	my $shortened = $len - 3;
	length $text > $shortened ? substr($text, 0, $shortened).'...' : $text;
}

sub pad {
	($_[0] < 10) ? '0'.$_[0] : $_[0];
}

sub format_date {
	my ($date, $time) = @_;

	my @lt = localtime(time);
	my $res = _print_date($date)
			. 'T'
			. _print_time($time);
			#. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end, %args) = @_;

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	
	if (exists $args{noabs}) {
		return $e - $s;
	}
	else {
		return abs($e - $s);
	}
}

sub _yesterday {
	my $dt = DateTime->now()->subtract( days => 1 );
	return {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
}

sub increment_time {
		my ($start, $increment) = @_;
		
		my $t = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
		$t += $increment;
		$t = 86400 if $t > 86400; # FIXME
		my $h = int($t / 3600);
		my $m = int($t / 60) % 60;
		my $s = $t % 60;
		return { H => $h, M => $m, S => $s };
}

sub get_pw {
	my $pw;
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$pw = $keyring->get_password($username, "wt_client");
		if(!$pw) {
			$pw = read_pw_from_console();
			$keyring->set_password($username, $pw, "wt_client");
		}
	}
	else {
		$pw = read_pw_from_console();
	}
	return $pw;
}

sub forget_pw {
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$keyring->clear_password($username, "wt_client");
	}
}

sub read_pw_from_console {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	ReadMode 0;
	print "\n";
	chomp $pw;
	return $pw;
}
