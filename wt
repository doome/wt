#!/usr/bin/perl

=pod

=head1 SYNOPSIS

wt - command line work log client

=head1 USAGE

    wt [-d DATE] HH:MM-HH:MM ISSUE COMMENT

=cut

## TODO
# date
# wt report, wt commit, wt start

use strict;
use warnings;
no warnings qw/experimental/;
use feature qw/say switch/;
#use Getopt::Long;
#use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Data::Dumper;

my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);

my $action = shift @ARGV;

for ($action) {
	when (undef)           { list_local(); }
	when ([qw/start s/])   { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ([qw/report r/])  { query();      }
	when ([qw/help h/])    { help();       }
	when ([qw/add a/])     { add();        }
	default                { help();       }
}


###############

sub help {
	my $action = shift // "";
	say "TODO help $action";
	exit;
}

sub list_local {
	say "TODO list local";
}

sub set_mark{
	$state->{start_mark} = parse_time(undef);
	
	my $project_str = shift @ARGV;
	if (defined $project_str) {
		my $project = parse_project($project_str);
		if (defined $project) {
			$state->{current_project} = $project;
		}
		else {
			$project_str //= "";
			warn "Warn: invalid project name '$project_str', must be in PROJECT-NUMBER format\n";
		}
		
	}
	
	save_state($state_fn, $state); 
}

sub commit {
	
	my $pw = get_pw();

	my @lines = @{$state->{local}};

	for my $wtline (@lines) {
		my $json = wtline_to_jira_json($wtline);
		say "FIXME $json";
		if (0) { # FIXME
		my $url = $config->{jira_base_url}.$config->{worklog_url};
		my $req = HTTP::Request->new('POST', $url);
		$req->header('Content-Type' => 'application/json');
		$req->authorization_basic($config->{user_name}, $pw);
		$req->content($json);
		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);
		
		if ( $response->is_success() ) {
			say "POST OK";
		}
		else {
			say Dumper $response;
		}
		}

		# delete locally stored wt line if commit was successful
		shift @{$state->{local}};
	}
	
	save_state($state_fn, $state);
}

sub query {
	say "TODO query";
	save_state($state_fn, $state);
}

sub add {
	my $interval = shift @ARGV;
	
	help("add") unless defined $interval;
	
	# optional first argument: date
	my $date = parse_date(undef); # get current date
	if ($interval eq "-d") {
		my $date_override = shift @ARGV;
		die "Error: you must specify a date with -d\n" unless defined $date_override;
		$date = parse_date($date_override);
		help("add") unless $date;
		$interval = shift @ARGV;
		help("add") unless defined $interval;
	}

	# first argument: from-to time
	my ($s, $e) = split '-', $interval;
	
	die "Error: no saved starting time available, you must specify it explicitly\n" if not defined $s and not defined $state->{start_mark};
	$s //= $state->{start_mark};
	my $start_time = parse_time($s);
	my $end_time   = parse_time($e);

	# second argument: project
	my $project_str = shift @ARGV;
	my $project = parse_project($project_str);
	$project_str //= "";
	die "Error: Invalid project name '$project_str', must be in PROJECT-NUMBER format\n" if not defined $project;

	# third argument: comment
	my $comment = shift @ARGV;
	die "Error: Comment is required\n" unless defined $comment;

	# assemble ojject and save it
	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $project,
		comment    => $comment,
	};

	push @{$state->{local}}, $wtline;
	
	$state->{current_project} = $project;
	$state->{start_mark} = $end_time;

	save_state($state_fn, $state);
}

###############

sub _load_json {
	my ($fn) = @_;
	open(my $FH, "<", $fn) or return undef;
	my $json = join "", <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	return _save_json($_[0], $_[1], "state");
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time});
	
	my $ojject = {
		issue => {
			#remainingEstimateSeconds => number,
			key => $wtline->{project}{name},
			projectId => $wtline->{project}{number},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	
}

###############

sub pad {
	($_[0] < 10) ? '0'.$_[0] : $_[0];
}

# if date is defined, try to parse it from YYYY-MM-DD or MM-DD or DD string, otherwise get current date
# if year or month is missing, it is substituted from current date
sub parse_date {
	my $dstr = shift;

	my @lt = localtime(time);
	my $date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};
	
	if (defined $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$date->{D} = $dstr;
		}
		elsif ($dstr =~ /^(\d\d?)-(\d\d?)$/) {
			$date->{M} = $1;
			$date->{D} = $2;
		}
		elsif ($dstr =~ /^(\d{4})-(\d\d?)-(\d\d?)$/) {
			$date->{Y} = $1;
			$date->{M} = $2;
			$date->{D} = $3;
		}
		else {
			$date = undef;
		}
	}
	return $date;
}

# if time is defined, try to parse it from HH-MM-SS or HH-MM or HH string, otherwise get current time
# if minutes or seconds are missing, they are assumed to be zero (whole hour/minute)
sub parse_time {
	my $dstr = shift;
	
	my @lt = localtime(time);
	my $time = {H => $lt[2], M => $lt[1], S => $lt[0]};
	
	if (defined $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$time->{H} = $dstr;
			$time->{M} = $time->{S} = 0;
		}
		elsif ($dstr =~ /^(\d\d?):(\d\d?)$/) {
			$time->{H} = $1;
			$time->{M} = $2;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^(\d\d?):(\d\d?):(\d\d?)$/) {
			$time->{H} = $1;
			$time->{M} = $2;
			$time->{S} = $3;
		}
		else {
			$time = undef;
		}
	}
	return $time;
}

# parse JIRA style PROJECT-NUM identifiers
sub parse_project {
	my $project_str = shift // "";
	my $project;
	($project->{name}, $project->{number}) = $project_str =~ /([\w_]+)-(\d+)/;
	return undef unless defined $project->{name} and defined $project->{number};
	return $project;
}

sub format_date {
	my ($date, $time) = @_;

	my @lt = localtime(time);
	my $res = (join "-", map { pad($date->{$_}) } qw/Y M D/)
			. 'T'
			. (join ":", map { pad($time->{$_}) } qw/H M S/)
			. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end) = @_;

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	return abs($e - $s);
}

sub get_pw {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	print "\n";
	ReadMode 0;
	return $pw;
}
