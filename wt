#!/usr/bin/perl

=pod

=head1 SYNOPSIS

wt - command line work log client

=head1 USAGE

Available subcommands:

    wt add [-d DATE] [HH[:MM]]-[HH[:MM]] ISSUE COMMENT
    wt commit
    wt start [ISSUE]
    wt report START END [ISSUE]
    wt rm INDEX|all
    wt
    wt help [SUBCOMMAND]


=head1 SUBCOMMANDS

=head2 ADD

    wt add [-d DATE] [HH[:MM]]-[HH[:MM]] ISSUE COMMENT

Adds an entry to the local list of wt entries.

There are three mandatory arguments:

    Interval: starting and ending time in HH:MM format, separated by a dash.
        If minutes are omitted, HH:00 is assumed.

        If the starting time is omitted altogether, 
        the saved start mark is used instead, if available.
        It is an error to omit the start if no start mark is available.

        If the ending time is omitted altogether, the current time is assumed.
        
        The ending time is also saved for the start mark of the next
        "wt add" command. Thus, the interval argument may consist of 
        just a single dash in certain cases, meaning 
        "from the end of the last entry till now".

    Issue: project or issue identifier, in PROJECT-NUMER format.
        A single dash means to use the current project, if one is available.

    Comment: arbitrary text (can contain spaces etc. if quoted) to describe
        the task/bugfix etc.

By default, the date for the entry is the current date. This can be overridden
by the -d switch, which requires a date string in YYYY-MM-DD format. 
If the year or month is omitted, the current year or month is substituted.

=head2 COMMIT

    wt commit

Attempt to commit local wt entries to JIRA.
Successfully committed entries are deleted from the list.

=head2 START

	wt start [ISSUE]

Saves a timestamp with the current time. In effect, this command means
"I'm starting work now". An optional project (issue) name can be specified,
it will be saved as the current project.

=head2 REPORT

    wt report START END [ISSUE]

Queries worklog entries from JIRA. TODO.

=head2 RM

    wt rm INDEX|all

Delete one local wt entry. The index number of the entry to be deleted is
the same as reported by "wt" without arguments.

Alternatively, if called as "wt rm all", all local entries are deleted.

=head2 LIST

    wt

(wt command without arguments)
List local wt entries.


=head2 HELP

    wt help [SUBCOMMAND]

Prints available subcommands if called without arguments,
or detailed help for a subcommand.

=cut

## TODO
# help, query, detect overlaps -_-

use strict;
use warnings;
no warnings qw/experimental/;
use feature qw/say switch/;
#use Getopt::Long;
use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Data::Dumper;

my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);

my $action = shift @ARGV;

for ($action) {
	when (undef)           { list_local(); }
	when ([qw/start s/])   { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ("report")        { query();      }
	when ([qw/help h/])    { help();       }
	when ([qw/add a/])     { add();        }
	when ("rm")            { rm();         }
	default                { help();       }
}


###############

sub help {
	my $action = shift // "";
	say "TODO help $action";
	exit;
}

sub list_local {
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		say join "\t",
			$i++, 
			(join "-", map { pad($wt->{date}->{$_}) } qw/Y M D/),
			(join ":", map { pad($wt->{start_time}->{$_}) } qw/H M S/),
			(join ":", map { pad($wt->{end_time}->{$_}) } qw/H M S/),
			$wt->{project}{name}."-".$wt->{project}{number},
			$wt->{comment};
	}
	say "No local wt records." unless scalar @{$state->{local}};
}

sub rm {
	my $idx = shift @ARGV;
	die "Error: specify the index of local wt record to be deleted" unless $idx;
	die "Error: no local wt records to delete\n" unless scalar @{$state->{local}};
	
	if ($idx eq "all") {
		$state->{local} = [];
		say "All local wt records deleted!";
	}
	else {
		die "Error: index must be 1..".scalar @{$state->{local}}."\n" unless $idx >= 1 and $idx <= scalar @{$state->{local}};
		# at this point we should have a valid index to delete
		splice @{$state->{local}}, $idx-1, 1;
	}
	save_state($state_fn, $state); 
	list_local();
}

sub set_mark{
	$state->{start_mark} = parse_time(undef);
	
	my $project_str = shift @ARGV;
	if (defined $project_str) {
		my $project = parse_project($project_str);
		if (defined $project) {
			$state->{current_project} = $project;
		}
		else {
			$project_str //= "";
			warn "Warn: invalid project name '$project_str', must be in PROJECT-NUMBER format\n";
		}
		
	}
	
	save_state($state_fn, $state); 
}

sub commit {
	
	my $pw = get_pw();

	my @lines = @{$state->{local}};

	for my $wtline (@lines) {
		my $json = wtline_to_jira_json($wtline);
		say "FIXME $json";
		if (0) { # FIXME
		my $url = $config->{jira_base_url}.$config->{worklog_url};
		my $req = HTTP::Request->new('POST', $url);
		$req->header('Content-Type' => 'application/json');
		$req->authorization_basic($config->{user_name}, $pw);
		$req->content($json);
		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);
		
		if ( $response->is_success() ) {
			say "POST OK";
		}
		else {
			say Dumper $response;
		}
		}

		# delete locally stored wt line if commit was successful
		shift @{$state->{local}};
	}
	
	save_state($state_fn, $state);
}

sub query {
	say "TODO query";
	save_state($state_fn, $state);
}

sub add {
	my $interval = shift @ARGV;
	
	help("add") unless defined $interval;
	
	# optional first argument: date
	my $date = parse_date(undef); # get current date
	if ($interval eq "-d") {
		my $date_override = shift @ARGV;
		die "Error: you must specify a date with -d\n" unless defined $date_override;
		$date = parse_date($date_override);
		help("add") unless $date;
		$interval = shift @ARGV;
		help("add") unless defined $interval;
	}

	# first argument: from-to time
	my ($s, $e) = split '-', $interval;
	
	#print Dumper $s, $e, $state;
	
	# If from is not specified, try to use saved start mark.
	# If there is no start mark either, give up.
	my $start_time;
	if (not $s) {
		if (defined $state->{start_mark}) {
			$start_time = $state->{start_mark};
		}
		else {
			die "Error: no saved starting time available, you must specify it explicitly\n";
		}
	}
	else {
		$start_time = parse_time($s);
	}
	# end time falls back to current time if not specified
	my $end_time = parse_time($e);

	# second argument: project
	my $project_str = shift @ARGV;
	my $project;
	if (defined $project_str) {
		if ($project_str eq "-") {
			# use saved current project
			$project = $state->{current_project};
			die "Error: no current project available\n" unless defined $project;
		}
		else {
			$project = parse_project($project_str);
			$project_str //= "";
			die "Error: Invalid project name '$project_str', must be in PROJECT-NUMBER format\n" unless defined $project;
		}
	}
	else {
		die "Error: project name is mandatory\n";

	}

	# third argument: comment
	my $comment = shift @ARGV;
	die "Error: Comment is required\n" unless defined $comment;

	# assemble ojject and save it
	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $project,
		comment    => $comment,
	};

	push @{$state->{local}}, $wtline;
	
	$state->{current_project} = $project;
	$state->{start_mark} = $end_time;

	save_state($state_fn, $state);
	list_local();
	#print Dumper $state;

}

###############

sub _load_json {
	my ($fn) = @_;
	open(my $FH, "<", $fn) or return undef;
	my $json = join "", <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	return _save_json($_[0], $_[1], "state");
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time});
	
	my $ojject = {
		issue => {
			#remainingEstimateSeconds => number,
			key => $wtline->{project}{name},
			projectId => $wtline->{project}{number},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	
}

###############

# if date is defined, try to parse it from YYYY-MM-DD or MM-DD or DD string, otherwise get current date
# if year or month is missing, it is substituted from current date
sub parse_date {
	my $dstr = shift;

	my @lt = localtime(time);
	my $date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};
	
	if (defined $dstr and $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$date->{D} = $dstr;
		}
		elsif ($dstr =~ /^(\d\d?)-(\d\d?)$/) {
			$date->{M} = $1;
			$date->{D} = $2;
		}
		elsif ($dstr =~ /^(\d{4})-(\d\d?)-(\d\d?)$/) {
			$date->{Y} = $1;
			$date->{M} = $2;
			$date->{D} = $3;
		}
		else {
			$date = undef;
		}
	}
	return $date;
}

# if time is defined, try to parse it from HH-MM-SS or HH-MM or HH string, otherwise get current time
# if minutes or seconds are missing, they are assumed to be zero (whole hour/minute)
sub parse_time {
	my $dstr = shift;
	
	my @lt = localtime(time);
	my $time = {H => $lt[2], M => $lt[1], S => $lt[0]};
	
	if (defined $dstr and $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$time->{H} = $dstr;
			$time->{M} = $time->{S} = 0;
		}
		elsif ($dstr =~ /^(\d\d?):(\d\d?)$/) {
			$time->{H} = $1;
			$time->{M} = $2;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^(\d\d?):(\d\d?):(\d\d?)$/) {
			$time->{H} = $1;
			$time->{M} = $2;
			$time->{S} = $3;
		}
		else {
			$time = undef;
		}
	}
	return $time;
}

# parse JIRA style PROJECT-NUM identifiers
sub parse_project {
	my $project_str = shift // "";
	my $project;
	($project->{name}, $project->{number}) = $project_str =~ /([\w_]+)-(\d+)/;
	return undef unless defined $project->{name} and defined $project->{number};
	return $project;
}

sub pad {
	($_[0] < 10) ? '0'.$_[0] : $_[0];
}

sub format_date {
	my ($date, $time) = @_;

	my @lt = localtime(time);
	my $res = (join "-", map { pad($date->{$_}) } qw/Y M D/)
			. 'T'
			. (join ":", map { pad($time->{$_}) } qw/H M S/)
			. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end) = @_;

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	return abs($e - $s);
}

sub get_pw {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	print "\n";
	ReadMode 0;
	return $pw;
}
