#!/usr/bin/perl

=pod

=head1 SYNOPSIS

wt - command line work log client

=head1 USAGE

Available subcommands:

    wt [add] [-d DATE|-y] [-c] [-a ACTIVITY] INTERVAL ISSUE COMMENT
    wt commit
    wt start [-c] [ISSUE]
    wt report [START] [END] [ISSUE]
    wt rm INDEX|all
    wt issues [-a] [-s|-j] [-m NUM] STRING
    wt
    wt help [SUBCOMMAND]


=head1 SUBCOMMANDS

=head2 ADD

    wt [add] [-d DATE|-y] [-c] [-a ACTIVITY] INTERVAL ISSUE COMMENT

Adds an entry to the local list of wt entries.

=head3 There are three mandatory arguments:

=over

=item Interval

Starting and ending time in B<HH:MM:SS> format, separated by a dash.

	[HH[:MM[:SS]]]-[HH[:MM[:SS]]]

If seconds are omitted, B<HH:MM:00> is assumed (whole minutes).
If minutes are omitted, B<HH:00:00> is assumed (whole hours).

If the starting time is omitted altogether, 
the saved start mark is used instead, if available.
It is an error to omit the start if no start mark is available.

If the ending time is omitted altogether, the current time is assumed.

The ending time is also saved for the start mark of the next
C<wt add> command. Thus, the interval argument may consist of 
just a single dash in certain cases, meaning 
"from the end of the last entry till now".

Alternatively, a relative interval may be specified with a C<+> (plus sign)
and a time specifier (B<HH:MM:SS>). Minutes and seconds may be omitted.
Fractional hours may also be specified. A C<m> suffix means minutes.

	+HH[:MM[:SS]]
	+HH.H
	+MMm

Starting time is taken from the start mark. The command fails if there
is no start mark available.

=item Issue

Project or issue identifier, in B<PROJECT-NUMBER> format.
A single dash means to use the current project, if one is available.

=item Comment

Arbitrary text (can contain spaces etc. if quoted) to describe
the task/bugfix etc.

=back

=head3 Options to the B<add> subcommand

=over

=item C<-a> Activity type

JIRA requires an activity type for each worklog entry. This can be
overridden with the C<-a> or C<--activity> switch.
The default activity type is "Dev".

=item C<-d> Set date

By default, the date for the entry is the current date. This can be overridden
by the C<-d> or C<--date> switch, which requires a date string in YYYY-MM-DD format. 
If the year or month is omitted, the current year or month is substituted.

=item C<-y> Yesterday

The C<-y> or C<--yesterday> switch sets the date to yesterday.

=item C<-c> Autocommit

By default, the C<add> subcommand only adds the entry to the local list, 
which must be committed with C<wt commit> separately.

This switch causes the entry to be committed immediately.

=back

=head3 Lunch and breaks

Specifying "lunch" as the issue name will cause the following:

=over

=item The project name will be substituted from the "lunch-project" key in 
wt.conf. If that key doesn't exist, the program terminates with an error.

=item The comment becomes optional, if omitted, "lunch" will be substituted.

=item The activity type will be set to "Break" unless explicitly overridden.

=back

The C<add> keyword may be omitted.

=head2 COMMIT

    wt commit
    wt ci

Attempt to commit local wt entries to JIRA.
Successfully committed entries are deleted from the list.

=head2 START

	wt start [-c|--change] [ISSUE]
	wt s ...

Saves a timestamp with the current time. In effect, this command means
"I'm starting work now". An optional project (issue) name can be specified,
it will be saved as the current project.

=head2 REPORT

    wt report [START] [END] [PROJECT]
    wt r ...

Queries worklog entries from JIRA.
If this subcommand is called with two date arguments, worklog entries between the two date
are queried from JIRA. Dates must be specified as YYYY-MM-DD.
If the year or month is omitted, the current year or month is substituted.

The end date may be omitted altogether, in which case the current date is assumed.

An optional third argument can be used to filter for project name.

If called without dates, prints the results of the last query
(but doesn't start a new query).

=head2 ISSUES

    wt issues [-a] [-s|-j] [-m NUM] [STRING]
    wt : ...

Query issues matching STRING from JIRA and print the resulting list.

Each entry contains the issue number, status, assignee and summary.

The list is sorted by date, latest is on the bottom.

If STRING looks like a JIRA issue (e.g. CG-54), it is assumed to be an issue number,
and the resulting list will contain that one issue (at most).
Otherwise, it is assumed to be a project number, and all issues under that project
are returned (if the project exists).

The -s or --summary switch can be used to search in the issue summaries instead.
In this case all issues are reported whose summaries match STRING.

Alternatively, the -j or --jql switch can be used to pass a raw JQL query string to JIRA.
The query string is not validated, just passed as is.

The -a or --assigned switch can be used to restrict the search to those issues 
that are assigned to the current user.

The -m or --max switch can be used to override the maximum number of issues reported, 
by default 100.

=head2 RM

    wt rm INDEX|all

Delete one local wt entry. The index number of the entry to be deleted is
the same as reported by "wt" without arguments.

Alternatively, if called as "wt rm all", all local entries are deleted.

=head2 LIST

    wt

(wt command without arguments)
List local wt entries.


=head2 HELP

    wt help [SUBCOMMAND]

Prints available subcommands if called without arguments,
or detailed help for a subcommand.

=head1 FILES

This program relies on two files called C<wt.conf> and C<wt.state>,
used to store user preferences and persistent state, respectively.

These files are expected to be in a directory called C<.wt> under the user's
home directory.

C<wt.conf>, the configuration file should be edited by the user before
attempting to use the program. It must be a valid JSON file.
The JSON object in it must have at least the following keys:

=over

=item jira_base_url

The base URL of the JIRA instance to which the worklog entries are to be
sent.

=item user_name

A valid JIRA user name, to be used for authentication.

=back

The following optional keys are also recognized:

=over

=item worklog_url

Override the standard REST API endpoint used by JIRA to submit/query
worklog entries

=item search_url

Override the standard REST API endpoint used by JIRA to search issues

=item lunch_project

Specify a JIRA issue for the C<wt add - lunch> feature

=back


Example:

	{
			"jira_base_url": "https://my.awesome.company.com/jira",
			"worklog_url": "/rest/tempo-timesheets/3/worklogs/",
			"search_url": "/rest/api/2/search",
			"user_name": "homer.simpson",
			"lunch_project": "CMPS-19"
	}

C<wt.state>, the file to store persistent state between consequent runs
of the program, is modified by most subcommands (the exceptions are C<wt>
without arguments and C<wt report> without arguments). It is also a JSON
file, however, it is not intended to be directly edited by the user.

=head1 SAVING JIRA PASSWORD

The C<commit>, C<issues>, and C<report> subcommand have to connect to 
the JIRA instance specified in the config file. This requires authentication,
in the form of an user name and password. The user name is also specified
in the config file, however, the password is not.

On systems that have a keyring (more precisely, any working keyring 
implementation supported by the Passwd::Keyring::Auto module, which must
also be installed), the password is asked only once, then saved into the
keyring safely.

On systems without keyring support the JIRA password is asked before every
command that needs JIRA access.

Storing the password in plaintext is not supported (nor is it recommended).

=cut

use strict;
use warnings;
no warnings qw/experimental/;
use feature qw/say switch/;
use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Time::Local;
use Data::Dumper;
use URI::Escape;
use DateTime;
use Getopt::Long;
use Encode::Locale;
use Encode;

our $have_keyring;
BEGIN {
	$have_keyring = eval {
		require Passwd::Keyring::Auto;
		Passwd::Keyring::Auto->import();
		1;
	};
}

my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);
my $ret = 0;

@ARGV = map { decode(locale => $_, 1) } @ARGV;

my $action = shift @ARGV;

binmode STDOUT, ":encoding(UTF-8)";

for ($action) {
	when (undef)           { list_local(); }
	when ([qw/start s/])   { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ([qw/issues :/])  { get_issues(); }
	when ("report")        { query();      }
	when ([qw/help h/])    { help();       }
	when ([qw/add a/])     { add();        }
	when ("rm")            { rm();         }
	default                { unshift @ARGV, $action; add(); }
}

exit($ret);

###############

sub help {
	my $action = shift // shift @ARGV // "";

	for ($action) {
		when (undef)           { pod2usage({-verbose => 99, -sections => "SYNOPSIS|USAGE"});     }
		when ([qw/start s/])   { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/START"});  }
		when ([qw/commit ci/]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/COMMIT"}); }
		when ([qw/issues :/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ISSUES"}); }
		when ("report")        { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/REPORT"}); }
		when ([qw/help h/])    { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/HELP"});   }
		when ([qw/add a/])     { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ADD"});    }
		when ("rm")            { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/RM"});     }
		default                { pod2usage({-verbose => 99, -sections => "SYNOPSIS|USAGE"});     }
	}

	exit;
}

sub list_local {
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		print print_wtline($wt, $i++);
	}
	if (@{$state->{local}}) {
		say "";
		say summary($state->{local});
	}
	else {
		say "No local wt records.";
		$ret = 1;
	}

	if (defined $state->{start_mark}) {
		my $interval = time_spent(parse_time(undef), $state->{start_mark});
		my ($h, $m, $s);
		$h = int($interval / 3600); $interval -= $h * 3600;
		$m = int($interval /   60); $interval -= $m *   60;
		$s = int($interval);
		$interval = ($h || '') . ($h ? ':' : '') . pad($m)  . ':' . pad($s);
		my $on_project =  defined $state->{current_project} ? "on issue $state->{current_project}" : "";
		say "Unlogged work: $interval $on_project";
	}
}

sub rm {
	my $idx = shift @ARGV;
	die "Error: specify the index of local wt record to be deleted" unless $idx;
	die "Error: no local wt records to delete\n" unless scalar @{$state->{local}};
	
	if ($idx eq "all") {
		$state->{local} = [];
		say "All local wt records deleted!";
	}
	else {
		die "Error: index must be 1..".scalar @{$state->{local}}."\n" unless $idx >= 1 and $idx <= scalar @{$state->{local}};
		# at this point we should have a valid index to delete
		splice @{$state->{local}}, $idx-1, 1;
		
		# update start mark to end of last entry
		if (@{$state->{local}}) {
			$state->{current_project} = $state->{local}[-1]{project};
			$state->{start_mark} = $state->{local}[-1]{end_time};
		}
	}
	save_state($state_fn, $state); 
	list_local();
}

sub set_mark {
	my $change = 0;
	GetOptions(
		'change!' => \$change,
	) or help('start');

	unless ($change) {
		$state->{start_mark} = parse_time(undef);
	}

	my $project_str = shift @ARGV;
	if (defined $project_str) {
		$state->{current_project} = $project_str;
	}
	elsif ($change) {
		$project_str //= "";
		die "Error: project name required for wt start --change\n";
	}

	save_state($state_fn, $state); 
}

sub commit {
	my $pw = get_pw();

	my @lines = @{$state->{local}};

	for my $wtline (@lines) {
		my $json = wtline_to_jira_json($wtline);
		my $worklog_url = $config->{jira_base_url}.$config->{worklog_url};
		my $req = HTTP::Request->new('POST', $worklog_url);
		$req->header('Content-Type' => 'application/json');
		$req->authorization_basic($config->{user_name}, $pw);
		$req->content($json);

		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);
		
		if ( $response->is_success() ) {
			# delete locally stored wt line if commit was successful
			shift @{$state->{local}};
		}
		else {
			_handle_jira_error($response);
		}
	}

	save_state($state_fn, $state);
}

sub query {
	my $start_date_str = shift @ARGV;
	
	if (defined $start_date_str) {
		my $start_date = parse_date($start_date_str);
		help('report') unless defined $start_date;

		my $end_date_str = shift @ARGV;
		my $end_date = parse_date($end_date_str);

		my $project = shift @ARGV;

		my $pw = get_pw();

		my $url = $config->{jira_base_url}.$config->{worklog_url};

		my %query_hash = (dateFrom => _print_date($start_date), dateTo => _print_date($end_date), username => $config->{user_name});
		$query_hash{projectKey} = $project if defined $project;
		my $query_string = uri_escape_hash(%query_hash);

		my $req = HTTP::Request->new('GET', $url."?".$query_string);
		$req->authorization_basic($config->{user_name}, $pw);

		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);

		if ( $response->is_success() ) {
			$state->{remote} = decode_json $response->decoded_content;

			update_saved_issue_summaries($state->{remote}, from => 'remote');

			list_remote(on_error => "No worklog records in the specified date range.");

			save_state($state_fn, $state);
		}
		else {
			_handle_jira_error($response);
		}
		
	}
	else {
		# print last saved query, don't actually ask jira
		list_remote(on_error => "There is no saved query.");
	} 

}

sub get_issues {
	my $assigned_to_me = 0;
	my $summary = 0;
	my $max = 100;
	my $raw_jql;
	GetOptions(
		'assigned!' => \$assigned_to_me,
		'summary!'  => \$summary,
		'max=i'     => \$max,
		'jql=s'     => \$raw_jql,
	) or help('issues');

	my $filter = shift @ARGV;
	my @jql;
	if (defined $filter) {
		if ($raw_jql) {
			push @jql, $filter;
		}
		elsif ($summary) {
			push @jql, "summary ~ $filter";
		}
		elsif ($filter =~ /\w+-\d+/) {
			push @jql, "issue = $filter";
		}
		else {
			push @jql, "project = $filter";
		}
	}
	if ($assigned_to_me) {
		push @jql, "assignee = " . $config->{user_name};
	}
	my $jql = join " and ", @jql;
	$jql .= " order by createddate desc" if $jql;

	my $pw = get_pw();
	
	my $json = encode_json {
		"jql" => $jql,
		"startAt" => 0,
		"maxResults" => $max,
		"fields" => [
			"summary",
			"status",
			"assignee"
		]
	};
	my $jira_url = $config->{jira_base_url}.$config->{search_url};
	my $req = HTTP::Request->new('POST', $jira_url);
	$req->header('Content-Type' => 'application/json;charset=UTF-8');
	$req->authorization_basic($config->{user_name}, $pw);
	$req->content($json);

	my $ua = LWP::UserAgent->new;
	my $response = $ua->request($req);
	
	if ( $response->is_success() ) {
		my $raw_data = decode_json $response->decoded_content;
		say for reverse map { 
				sprintf "%-8s%-16s%-16s%s", 
					$_->{key}, 
					_trunc($_->{fields}{status}{name}, 15), 
					$_->{fields}{assignee}{name} // "", 
					$_->{fields}{summary}
				} 
			@{$raw_data->{issues}};

		update_saved_issue_summaries($raw_data->{issues}, from => 'issuelist');
		save_state($state_fn, $state);
	}
	else {
		_handle_jira_error($response);
	}
	
}

sub add {
	help("add") unless defined $ARGV[0];

	# get current date as default
	my $date = parse_date(undef);

	# defaults
	my $autocommit = 0;
	my $activity = undef;

	# need to check if first arg is interval spec (single dash or dash-number)
	# before calling GetOptions
	unless ($ARGV[0] =~ /^\-$|^\-\d|^\+/) {
		GetOptions(
			'date=s'     => sub { $date = parse_date($_[1]); },
			'yesterday!' => sub { $date = _yesterday(); },
			'commit!'    => \$autocommit,
			'activity=s' => \$activity,
		) or help('add');
	}

	# first argument: from-to time or relative interval
	my $interval = shift @ARGV;
	my ($start_time, $end_time);

	# relative interval
	if (index($interval, '+') == 0) {
		if (defined $state->{start_mark}) {
			$start_time = $state->{start_mark};
		}
		else {
			die "Error: no saved starting time available, you must specify the interval explicitly\n";
		}
		my $t = parse_time($interval) or die "Invalid interval spec '$interval', must be +HH:MM or +HH or +MMm\n";

		$end_time = increment_time($start_time, time_spent({H=>0, M=>0, S=>0}, $t));
	}
	# absolute interval
	else {
		my ($s, $e) = split '-', $interval;

		# If from is not specified, try to use saved start mark.
		# If there is no start mark either, give up.
		if (not defined $s or $s eq '') {
			if (defined $state->{start_mark}) {
				$start_time = $state->{start_mark};
			}
			else {
				die "Error: no saved starting time available, you must specify it explicitly\n";
			}
		}
		else {
			$start_time = parse_time($s) or die "Invalid time spec '$s', must be HH:MM\n";
		}
		# end time falls back to current time if not specified
		$end_time = parse_time($e) or die "Invalid time spec '$e', must be HH:MM\n";
	}

	die "Error: ending time must be later than starting time\n" if time_spent($start_time, $end_time, noabs => 1) <= 0;

	# second argument: project
	my $project_str = shift @ARGV;
	my $project;
	if (defined $project_str) {
		if ($project_str eq "-") {
			# use saved current project
			$project = $state->{current_project};
			die "Error: no current project available\n" unless defined $project;
		}
		elsif ($project_str eq "lunch") {
			# special hack: shortcut for lunch
			$project = $config->{lunch_project};
			die "Error: lunch project is not defined, edit wt.conf\n" unless defined $project;
		}
		else {
			$project = uc $project_str;
			$project_str //= "";
			die "Error: Invalid project name '$project_str', must be in PROJECT-NUMBER format\n" unless defined $project;
		}
	}
	else {
		die "Error: project name is mandatory\n";
	}

	# third argument: comment
	# rest of @ARGV is concatenated so that quotes are not needed
	my $comment = "@ARGV";
	# special hack: no comment is required for lunch
	$comment = "lunch" if $comment eq '' and $project_str eq "lunch";
	die "Error: Comment is required\n" if $comment eq '';

	# activity may have been set by option
	# special hack: no comment is required for lunch
	$activity = "Break" if not defined $activity and $project_str eq "lunch";
	$activity //= 'Dev';

	# assemble ojject and save it
	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $project,
		comment    => $comment,
		activity   => $activity,
	};

	if (my $overlap_idx = check_overlap($wtline)) {
		die "Error: input overlaps with existing entry:\n" .
			 print_wtline($state->{local}[$overlap_idx-1], $overlap_idx) .
			 print_wtline($wtline, undef);
	}

	push @{$state->{local}}, $wtline;
	
	$state->{current_project} = $project;
	$state->{start_mark} = $end_time;

	save_state($state_fn, $state);
	list_local();

	if ($autocommit) {
		commit();
	}
}

###############

sub _load_json {
	my ($fn) = @_;
	open(my $FH, "<", $fn) or return undef;
	my $json = join "", <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	die "Missing key from config file: jira_base_url\n" unless defined $config->{jira_base_url};
	die "Missing key from config file: user_name\n" unless defined $config->{user_name};
	$config->{worklog_url} //= "/rest/tempo-timesheets/3/worklogs/";
	$config->{search_url}  //= "/rest/api/2/search";

	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	return _save_json($_[0], $_[1], "state");
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time});
	
	my $ojject = {
		issue => {
			key => $wtline->{project},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
		billedSeconds => 0,
		worklogAttributes => [
			 {
			   'value' => $wtline->{activity},
			   'key' => '_Activity_'
			 }
        ],
		author => { 
			name => $config->{user_name} 
		},
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	my $jira = shift;
	
	my ($ds, $ts) = split 'T', $jira->{dateStarted};
	my $date = parse_date($ds);
	my $start_time = parse_time($ts);
	my $end_time = increment_time($start_time, $jira->{timeSpentSeconds});
	
	return {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $jira->{issue}{key},
		comment    => $jira->{comment},
		activity   => $jira->{worklogAttributes}[0]{value},
	};
}

sub print_wtline {
	my $wt = shift;
	my $idx = shift // 'X';
	
	return join "\t",
		$idx,
		_print_date($wt->{date}),
		_print_time($wt->{start_time}),
		_print_time($wt->{end_time}),
		$wt->{project},
		$wt->{comment},
		$wt->{activity},
		"\n";
}

sub uri_escape_hash {
    my %hash = @_;
    my @pairs;
    for my $key (keys %hash) {
        push @pairs, join "=", map { uri_escape($_) } $key, $hash{$key};
    }
    return join "&", @pairs;
}

sub update_saved_issue_summaries {
	my $issuelist = shift;
	my %args = @_;

	my %actions = (
		remote => sub {
				$state->{issues}->{ $_->{issue}{key} } = $_->{issue}{summary} for @_;
			},
		issuelist => sub {
				$state->{issues}->{ $_->{key} } = $_->{fields}{summary} for @_;
			}
	);
	if (defined $args{from} and exists $actions{ $args{from} }) {
		$actions{ $args{from} }->(@$issuelist);
	}
}

sub summary {
	my $wt_arr = shift;
	
	my %times;
	my $cumulative_time = 0;
	for my $wt (@$wt_arr) {
		my $dt = time_spent($wt->{start_time}, $wt->{end_time});
		$times{ $wt->{project} } += $dt;
		$cumulative_time += $dt;
	}

	my $summary_lines = join "", map {
			sprintf("% .2f\t%s\t%s\n", ($times{$_}/3600), $_, (exists $state->{issues}{$_} ? $state->{issues}{$_} : ""))
		} 
		sort { 
			$times{$b} <=> $times{$a} 
		} 
		keys %times;
	
	return $summary_lines . "------\n" . sprintf "%.2f", $cumulative_time/3600;
}

sub list_remote {
	my %args = @_;
	my $i = 1;
	my @remote = @{$state->{remote}};
	for my $csira (@remote) {
		print print_wtline(jira_json_to_wtline($csira), $i++);
	}
	if (@remote) {
		say "";
		say summary([ map {jira_json_to_wtline($_)} @remote ]);
	}
	else {
		say $args{on_error};
		$ret = 1;
	}
}

sub _handle_jira_error {
	my $response = shift;

	warn "JIRA responded with ".$response->status_line."\n";
	if ($response->code() == 401) {
		forget_pw();
	}
	else {
		my $error = decode_json $response->decoded_content;
		say STDERR join "\n", @{$error->{errorMessages}};
	}
	$ret = 1;
}

###############

sub _print_date {
	join "-", map { pad($_[0]->{$_}) } qw/Y M D/;
}

sub _print_time {
	join ":", map { pad($_[0]->{$_}) } qw/H M S/;
}

sub _wt2tfe {
	my ($t, $d) = @_;
	return timelocal(
		$t->{S}, $t->{M},   $t->{H}, 
		$d->{D}, $d->{M}-1, $d->{Y}
	);
}

sub check_overlap {
	my $new = shift;
	
	my $new_start = _wt2tfe($new->{start_time}, $new->{date});
	my $new_end   = _wt2tfe($new->{end_time},   $new->{date});
	
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		my $wt_start = _wt2tfe($wt->{start_time}, $wt->{date});
		my $wt_end   = _wt2tfe($wt->{end_time},   $wt->{date});
		
		return $i unless (($new_start <= $wt_end and $new_end <= $wt_start) or ($new_start >= $wt_end and $new_end >= $wt_start));
		$i++;
	}
	
	return 0;
}

# if date is defined, try to parse it from YYYY-MM-DD or MM-DD or DD string, otherwise get current date
# if year or month is missing, it is substituted from current date
sub parse_date {
	my $dstr = shift;

	my @lt = localtime(time);
	my $date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};
	
	if (defined $dstr and $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$date->{D} = 0+$dstr;
		}
		elsif ($dstr =~ /^(\d\d?)-(\d\d?)$/) {
			$date->{M} = 0+$1;
			$date->{D} = 0+$2;
		}
		elsif ($dstr =~ /^(\d{4})-(\d\d?)-(\d\d?)$/) {
			$date->{Y} = 0+$1;
			$date->{M} = 0+$2;
			$date->{D} = 0+$3;
		}
		else {
			$date = undef;
		}
	}
	return $date;
}

# if time is defined, try to parse it from HH-MM-SS or HH-MM or HH string, otherwise get current time
# if minutes or seconds are missing, they are assumed to be zero (whole hour/minute)
# +HH:MM or +HH.H or +MMm relative intervals are also parsed here
sub parse_time {
	my $dstr = shift;

	my @lt = localtime(time);
	my $time = {H => $lt[2], M => $lt[1], S => $lt[0]};

	my $is_interval = 0;
	if (defined $dstr and $dstr ne '') {
		if (index($dstr, '+') == 0) {
			substr($dstr, 0, 1, '');
			$is_interval = 1;
		}

		if ($is_interval and $dstr =~ /^(\d\d?)\.(\d+)$/) {
			$time->{H} = 0+$1;
			$time->{M} = int($2 * 6 + 0.5); # * 60 / 10
			$time->{S} = 0;
		}
		elsif ($is_interval and $dstr =~ /^(\d+)m$/) {
			my $m = 0+$1;
			$time->{H} = int($m / 60);
			$time->{M} = $m % 60;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^\d\d?$/) {
			$time->{H} = 0+$dstr;
			$time->{M} = $time->{S} = 0;
		}
		elsif ($dstr =~ /^(\d\d?):(\d\d?)$/) {
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^(\d\d?):(\d\d?):(\d\d?)/) { # drop fractional seconds
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0+$3;
		}
		else {
			$time = undef;
		}
	}
	return $time;
}

sub _trunc {
	my ($text, $len) = @_;
	my $shortened = $len - 3;
	length $text > $shortened ? substr($text, 0, $shortened).'...' : $text;
}

sub pad {
	($_[0] < 10) ? '0'.$_[0] : $_[0];
}

sub format_date {
	my ($date, $time) = @_;

	my @lt = localtime(time);
	my $res = _print_date($date)
			. 'T'
			. _print_time($time);
			#. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end, %args) = @_;

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	
	if (exists $args{noabs}) {
		return $e - $s;
	}
	else {
		return abs($e - $s);
	}
}

sub _yesterday {
	my $dt = DateTime->now()->subtract( days => 1 );
	return {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
}

sub increment_time {
		my ($start, $increment) = @_;
		
		my $t = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
		$t += $increment;
		$t = 86400 if $t > 86400; # FIXME
		my $h = int($t / 3600);
		my $m = int($t / 60) % 60;
		my $s = $t % 60;
		return { H => $h, M => $m, S => $s };
}

sub get_pw {
	my $pw;
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$pw = $keyring->get_password($username, "wt_client");
		if(!$pw) {
			$pw = read_pw_from_console();
			$keyring->set_password($username, $pw, "wt_client");
		}
	}
	else {
		$pw = read_pw_from_console();
	}
	return $pw;
}

sub forget_pw {
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$keyring->clear_password($username, "wt_client");
	}
}

sub read_pw_from_console {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	ReadMode 0;
	print "\n";
	chomp $pw;
	return $pw;
}
