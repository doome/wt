#!/usr/bin/perl

=pod

=head1 SYNOPSIS

wt - command line work log client

=head1 USAGE

    wt [-d DATE] HH:MM-HH:MM ISSUE COMMENT

=cut

## TODO
# date
# wt report, wt commit, wt start

use strict;
use warnings;
no warnings qw/experimental/;
use feature qw/say switch/;
use Getopt::Long;
use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Data::Dumper;

my $date_override;
GetOptions(
	"date=s" => \$date_override,
) or pod2usage();

my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);

my $action = shift @ARGV;

for ($action) {
	when (undef)           { list_local(); }
	when ([qw/start s/])   { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ([qw/report r/])  { query();      }
	when ([qw/help h/])    { help();       }
	when ([qw/add a/])     { add();        }
	default                { help();       }
}


###############

sub help {
	say "help";
}

sub list_local {
	say "list local";
}

sub set_mark{
	say "set mark";
	save_state($state_fn, $state); 
}

sub commit {
	
	my $pw = get_pw();

	my @lines = @{$state->{local}};

	for my $wtline (@lines) {
		my $json = wtline_to_jira_json($wtline);
		if (0) { # FIXME
		my $url = $config->{jira_base_url}.$config->{worklog_url};
		my $req = HTTP::Request->new('POST', $url);
		$req->header('Content-Type' => 'application/json');
		$req->authorization_basic($config->{user_name}, $pw);
		$req->content($json);
		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);
		
		if ( $response->is_success() ) {
			say "POST OK";
		}
		else {
			say Dumper $response;
		}
		}

		# delete locally stored wt line if commit was successful
		shift @{$state->{local}};
	}
	
	save_state($state_fn, $state);
}

sub query {
	say "query";
	save_state($state_fn, $state);
}

sub add {
	my $interval = shift @ARGV;
	my ($s, $e) = $interval =~ /(\d*:?\d*:?\d*)-(\d*:?\d*:?\d*)/;
	pod2usage() if (not defined $s or not defined $e); # TODO - allowed once wt start is available
	my %t;
	@t{qw/H M S/} = split ':', $s;
	my $start_time   = {%t};
	@t{qw/H M S/} = split ':', $e;
	my $end_time     = {%t};

	my $project_str = shift @ARGV;
	my %project;
	($project{name}, $project{number}) = $project_str =~ /([\w_]+)-(\d+)/;
	die "Error: Invalid project name, must be in PROJECT-NUMBER format\n" if (not defined $project{name} or not defined $project{number});

	my $comment = shift @ARGV;
	die "Error: Comment is required\n" unless defined $comment;

	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => undef, # TODO
		project    => { %project },
		comment    => $comment,
	};

	push @{$state->{local}}, $wtline;
	
	$state->{current_project} = { %project };
	$state->{start_mark} = $end_time;

	save_state($state_fn, $state);
}

###############

sub _load_json {
	my ($fn) = @_;
	open(my $FH, "<", $fn) or return undef;
	my $json = join "", <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	return _save_json($_[0], $_[1], "state");
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time});
	
	my $ojject = {
		issue => {
			#remainingEstimateSeconds => number,
			key => $wtline->{project}{name},
			projectId => $wtline->{project}{number},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	
}

###############

sub pad {
	($_[0] < 10) ? '0'.$_[0] : $_[0];
}

sub format_date {
	my ($date, $time) = @_;
	my @lt = localtime(time);
	if (not defined $date or ref $date ne "HASH") {
		$date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};
	}
	if (not defined $time or ref $time ne "HASH") {
		$time = {H => $lt[2], M => $lt[1], S => $lt[0]};
	}

	my $res = (join "-", map { pad($date->{$_}) } qw/Y M D/)
			. 'T'
			. (join ":", map { pad($time->{$_}) } qw/H M S/)
			. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end) = @_;
	my @lt = localtime(time);
	if (not defined $start or ref $start ne "HASH") {
		$start = {H => $lt[2], M => $lt[1], D => $lt[0]};
	}
	if (not defined $end or ref $end ne "HASH") {
		$end   = {H => $lt[2], M => $lt[1], D => $lt[0]};
	}

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	return abs($e - $s);
}

sub get_pw {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	print "\n";
	ReadMode 0;
	return $pw;
}
