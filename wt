#!/usr/bin/perl

=pod

=head1 SYNOPSIS

wt - command line work log client

=head1 USAGE

Available subcommands:

    wt add [-d DATE] [HH[:MM]]-[HH[:MM]] ISSUE COMMENT [ACTIVITY]
    wt commit
    wt start [ISSUE]
    wt report [START] [END] [ISSUE]
    wt rm INDEX|all
    wt
    wt help [SUBCOMMAND]


=head1 SUBCOMMANDS

=head2 ADD

    wt add [-d DATE] [HH[:MM]]-[HH[:MM]] ISSUE COMMENT [ACTIVITY]

Adds an entry to the local list of wt entries.

There are three mandatory arguments:

    Interval: starting and ending time in HH:MM format, separated by a dash.
        If minutes are omitted, HH:00 is assumed.

        If the starting time is omitted altogether, 
        the saved start mark is used instead, if available.
        It is an error to omit the start if no start mark is available.

        If the ending time is omitted altogether, the current time is assumed.
        
        The ending time is also saved for the start mark of the next
        "wt add" command. Thus, the interval argument may consist of 
        just a single dash in certain cases, meaning 
        "from the end of the last entry till now".

    Issue: project or issue identifier, in PROJECT-NUMER format.
        A single dash means to use the current project, if one is available.

    Comment: arbitrary text (can contain spaces etc. if quoted) to describe
        the task/bugfix etc.

The fourth, optional argument specifies the activity type. 
If omitted, it is set to "Dev".

By default, the date for the entry is the current date. This can be overridden
by the -d switch, which requires a date string in YYYY-MM-DD format. 
If the year or month is omitted, the current year or month is substituted.

=head2 COMMIT

    wt commit

Attempt to commit local wt entries to JIRA.
Successfully committed entries are deleted from the list.

=head2 START

	wt start [ISSUE]

Saves a timestamp with the current time. In effect, this command means
"I'm starting work now". An optional project (issue) name can be specified,
it will be saved as the current project.

=head2 REPORT

    wt report [START] [END] [PROJECT]

Queries worklog entries from JIRA.
If this subcommand is called with two date arguments, worklog entries between the two date
are queried from JIRA. Dates must be specified as YYYY-MM-DD.
If the year or month is omitted, the current year or month is substituted.

The end date may be omitted altogether, in which case the current date is assumed.

An optional third argument can be used to filter for project name.

If called without dates, prints the results of the last query
(but doesn't start a new query).

=head2 RM

    wt rm INDEX|all

Delete one local wt entry. The index number of the entry to be deleted is
the same as reported by "wt" without arguments.

Alternatively, if called as "wt rm all", all local entries are deleted.

=head2 LIST

    wt

(wt command without arguments)
List local wt entries.


=head2 HELP

    wt help [SUBCOMMAND]

Prints available subcommands if called without arguments,
or detailed help for a subcommand.

=cut

## TODO
# commit, query

use strict;
use warnings;
no warnings qw/experimental/;
use feature qw/say switch/;
use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Time::Local;
use Data::Dumper;
use URI::Escape;

my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);

my $action = shift @ARGV;

for ($action) {
	when (undef)           { list_local(); }
	when ([qw/start s/])   { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ("report")        { query();      }
	when ([qw/help h/])    { help();       }
	when ([qw/add a/])     { add();        }
	when ("rm")            { rm();         }
	default                { help();       }
}


###############

sub help {
	my $action = shift // shift @ARGV // "";

	for ($action) {
		when (undef)           { pod2usage({-verbose => 99, -sections => "SYNOPSIS|USAGE"});     }
		when ([qw/start s/])   { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/START"});  }
		when ([qw/commit ci/]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/COMMIT"}); }
		when ("report")        { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/REPORT"}); }
		when ([qw/help h/])    { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/HELP"});   }
		when ([qw/add a/])     { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ADD"});    }
		when ("rm")            { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/RM"});     }
		default                { pod2usage({-verbose => 99, -sections => "SYNOPSIS|USAGE"});     }
	}

	exit;
}

sub list_local {
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		print print_wtline($wt, $i++);
	}
	say "No local wt records." unless scalar @{$state->{local}};
}

sub rm {
	my $idx = shift @ARGV;
	die "Error: specify the index of local wt record to be deleted" unless $idx;
	die "Error: no local wt records to delete\n" unless scalar @{$state->{local}};
	
	if ($idx eq "all") {
		$state->{local} = [];
		say "All local wt records deleted!";
	}
	else {
		die "Error: index must be 1..".scalar @{$state->{local}}."\n" unless $idx >= 1 and $idx <= scalar @{$state->{local}};
		# at this point we should have a valid index to delete
		splice @{$state->{local}}, $idx-1, 1;
	}
	save_state($state_fn, $state); 
	list_local();
}

sub set_mark{
	$state->{start_mark} = parse_time(undef);
	
	my $project_str = shift @ARGV;
	if (defined $project_str) {
		my $project = parse_project($project_str);
		if (defined $project) {
			$state->{current_project} = $project;
		}
		else {
			$project_str //= "";
			warn "Warn: invalid project name '$project_str', must be in PROJECT-NUMBER format\n";
		}
		
	}
	
	save_state($state_fn, $state); 
}

sub commit {
	
	my $pw = get_pw();

	my @lines = @{$state->{local}};

	for my $wtline (@lines) {
		my $json = wtline_to_jira_json($wtline);
		my $worklog_url = $config->{jira_base_url}.$config->{worklog_url};
		my $req = HTTP::Request->new('POST', $worklog_url);
		$req->header('Content-Type' => 'application/json');
		$req->authorization_basic($config->{user_name}, $pw);
		$req->content($json);

		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);
		
		if ( $response->is_success() ) {
			# delete locally stored wt line if commit was successful
			shift @{$state->{local}};
		}
		else {
			warn "JIRA responded with ".$response->status_line."\n";
			say Dumper $response;
		}
		
	}
	
	save_state($state_fn, $state);
}

sub query {
	my $start_date_str = shift @ARGV;
	
	if (defined $start_date_str) {
		my $start_date = parse_date($start_date_str);
		pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/REPORT"}) unless defined $start_date;
		 
		my $end_date_str = shift @ARGV;
		my $end_date = parse_date($end_date_str);
		
		my $project = shift @ARGV;
		
		
		
		my $pw = get_pw();
		
		my $url = $config->{jira_base_url}.$config->{worklog_url};
		
		my %query_hash = (dateFrom => _print_date($start_date), dateTo => _print_date($end_date), username => $config->{user_name});
		$query_hash{projectKey} = $project if defined $project;
		my $query_string = uri_escape_hash(%query_hash);
		
		my $req = HTTP::Request->new('GET', $url."?".$query_string);
		$req->authorization_basic($config->{user_name}, $pw);

		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);
		
		if ( $response->is_success() ) {
			$state->{remote} = decode_json $response->decoded_content;
			my $i = 1;
			for my $csira (@{$state->{remote}}) {
				print print_wtline(jira_json_to_wtline($csira), $i++);
			}
			save_state($state_fn, $state);

		}
		else {
			die "JIRA responded with ".$response->status_line."\n";
		}
		
	}
	else {
		# print last saved query, don't actually ask jira
		my $i = 1;
		for my $csira (@{$state->{remote}}) {
			print print_wtline(jira_json_to_wtline($csira), $i++);
		}
		say "There is no saved query." unless scalar @{$state->{remote}};
	} 
	
}

sub add {
	my $interval = shift @ARGV;
	
	help("add") unless defined $interval;
	
	# optional first argument: date
	my $date = parse_date(undef); # get current date
	if ($interval eq "-d") {
		my $date_override = shift @ARGV;
		die "Error: you must specify a date with -d\n" unless defined $date_override;
		$date = parse_date($date_override);
		help("add") unless $date;
		$interval = shift @ARGV;
		help("add") unless defined $interval;
	}

	# first argument: from-to time
	my ($s, $e) = split '-', $interval;
	
	#print Dumper $s, $e, $state;
	
	# If from is not specified, try to use saved start mark.
	# If there is no start mark either, give up.
	my $start_time;
	if (not $s) {
		if (defined $state->{start_mark}) {
			$start_time = $state->{start_mark};
		}
		else {
			die "Error: no saved starting time available, you must specify it explicitly\n";
		}
	}
	else {
		$start_time = parse_time($s);
	}
	# end time falls back to current time if not specified
	my $end_time = parse_time($e);

	die "Error: ending time must be later than starting time\n" if time_spent($start_time, $end_time, noabs => 1) <= 0;

	# second argument: project
	my $project_str = shift @ARGV;
	my $project;
	if (defined $project_str) {
		if ($project_str eq "-") {
			# use saved current project
			$project = $state->{current_project};
			die "Error: no current project available\n" unless defined $project;
		}
		else {
			$project = uc $project_str;
			$project_str //= "";
			die "Error: Invalid project name '$project_str', must be in PROJECT-NUMBER format\n" unless defined $project;
		}
	}
	else {
		die "Error: project name is mandatory\n";

	}

	# third argument: comment
	my $comment = shift @ARGV;
	die "Error: Comment is required\n" unless defined $comment;

	# fourth argument: activity type
	my $activity = shift @ARGV // 'Dev';

	# assemble ojject and save it
	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $project,
		comment    => $comment,
		activity   => $activity,
	};

	if (my $overlap_idx = check_overlap($wtline)) {
		die "Error: input overlaps with existing entry:\n" .
			 print_wtline($state->{local}[$overlap_idx-1], $overlap_idx) .
			 print_wtline($wtline, undef);
	}

	push @{$state->{local}}, $wtline;
	
	$state->{current_project} = $project;
	$state->{start_mark} = $end_time;

	save_state($state_fn, $state);
	list_local();
	#print Dumper $state;

}

###############

sub _load_json {
	my ($fn) = @_;
	open(my $FH, "<", $fn) or return undef;
	my $json = join "", <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	return _save_json($_[0], $_[1], "state");
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time}); # {H=>0, M=>0, S=>0}
	
	my $ojject = {
		issue => {
			#remainingEstimateSeconds => number,
			key => $wtline->{project},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
		#projectId => 10400, # FIXME
		worklogAttributes => [
			 {
			   'value' => $wtline->{activity},
			   'key' => '_Activity_'
			 }
        ],
		author => { 
			name => $config->{user_name} 
		},
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	my $jira = shift;
	
	my ($ds, $ts) = split 'T', $jira->{dateStarted};
	my $date = parse_date($ds);
	my $start_time = parse_time($ts);
	my $end_time = increment_time($start_time, $jira->{timeSpentSeconds});
	
	return {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $jira->{issue}{key},
		comment    => $jira->{comment},
		activity   => $jira->{worklogAttributes}[0]{value},
	};
}

sub print_wtline {
	my $wt = shift;
	my $idx = shift // 'X';
	
	return join "\t",
		$idx,
		_print_date($wt->{date}),
		_print_time($wt->{start_time}),
		_print_time($wt->{end_time}),
		$wt->{project},
		$wt->{comment},
		$wt->{activity},
		"\n";
}

sub uri_escape_hash {
    my %hash = @_;
    my @pairs;
    for my $key (keys %hash) {
        push @pairs, join "=", map { uri_escape($_) } $key, $hash{$key};
    }
    return join "&", @pairs;
}

###############

sub _print_date {
	join "-", map { pad($_[0]->{$_}) } qw/Y M D/;
}

sub _print_time {
	join ":", map { pad($_[0]->{$_}) } qw/H M S/;
}

sub _wt2tfe {
	my ($t, $d) = @_;
	return timelocal(
		$t->{S}, $t->{M},   $t->{H}, 
		$d->{D}, $d->{M}-1, $d->{Y}
	);
}

sub check_overlap {
	my $new = shift;
	
	#$time = timelocal( $sec, $min, $hour, $mday, $mon, $year );
	my $new_start = _wt2tfe($new->{start_time}, $new->{date});
	my $new_end   = _wt2tfe($new->{end_time},   $new->{date});
	
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		my $wt_start = _wt2tfe($wt->{start_time}, $wt->{date});
		my $wt_end   = _wt2tfe($wt->{end_time},   $wt->{date});
		
		return $i unless (($new_start <= $wt_end and $new_end <= $wt_start) or ($new_start >= $wt_end and $new_end >= $wt_start));
		$i++;
	}
	
	return 0;
}

# if date is defined, try to parse it from YYYY-MM-DD or MM-DD or DD string, otherwise get current date
# if year or month is missing, it is substituted from current date
sub parse_date {
	my $dstr = shift;

	my @lt = localtime(time);
	my $date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};
	
	if (defined $dstr and $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$date->{D} = 0+$dstr;
		}
		elsif ($dstr =~ /^(\d\d?)-(\d\d?)$/) {
			$date->{M} = 0+$1;
			$date->{D} = 0+$2;
		}
		elsif ($dstr =~ /^(\d{4})-(\d\d?)-(\d\d?)$/) {
			$date->{Y} = 0+$1;
			$date->{M} = 0+$2;
			$date->{D} = 0+$3;
		}
		else {
			$date = undef;
		}
	}
	return $date;
}

# if time is defined, try to parse it from HH-MM-SS or HH-MM or HH string, otherwise get current time
# if minutes or seconds are missing, they are assumed to be zero (whole hour/minute)
sub parse_time {
	my $dstr = shift;
	
	my @lt = localtime(time);
	my $time = {H => $lt[2], M => $lt[1], S => $lt[0]};
	
	if (defined $dstr and $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$time->{H} = 0+$dstr;
			$time->{M} = $time->{S} = 0;
		}
		elsif ($dstr =~ /^(\d\d?):(\d\d?)$/) {
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^(\d\d?):(\d\d?):(\d\d?)/) { # drop fractional seconds
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0+$3;
		}
		else {
			$time = undef;
		}
	}
	return $time;
}

sub pad {
	($_[0] < 10) ? '0'.$_[0] : $_[0];
}

sub format_date {
	my ($date, $time) = @_;

	my @lt = localtime(time);
	my $res = _print_date($date)
			. 'T'
			. _print_time($time);
			#. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end, %args) = @_;

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	
	if (exists $args{noabs}) {
		return $e - $s;
	}
	else {
		return abs($e - $s);
	}
}

sub increment_time {
		my ($start, $increment) = @_;
		
		my $t = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
		$t += $increment;
		$t = 86400 if $t > 86400; # FIXME
		my $h = int($t / 3600);
		my $m = int($t / 60) % 60;
		my $s = $t % 60;
		return { H => $h, M => $m, S => $s };
}

sub get_pw {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	ReadMode 0;
	print "\n";
	chomp $pw;
	return $pw;
}
